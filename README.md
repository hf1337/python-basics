# Основы синтаксиса Python

![Python](/img/python.png)

## Содержание

* [1. Арифметика](#1-арифметика)
  * [1.1 Операторы и операнды](#11-операторы-и-операнды)
  * [1.2 Коммуникативные операции](#12-коммуникативные-операции)
  * [1.3 Композиция операций](#13-композиция-операций)
  * [1.4 Числа с плавающей точкой](#14-числа-с-плавающей-точкой)
* [2. Строки](#2-строки)
  * [2.1 Кавычки](#21-кавычки)
  * [2.2 Экранированные последовательности](#22-экранированные-последовательности)
  * [2.3 Конкатенация](#23-конкатенация)
  * [2.4 Кодировка](#24-кодировка)
* [3. Переменные](#3-переменные)
  * [3.1 Применение переменных](#31-применение-переменных)
  * [3.2 Изменение переменных](#32-изменение-переменных)
  * [3.3 Назначение имён для переменных](#33-назначение-имён-для-переменных)
  * [3.4 Выражения в определениях](#34-выражения-в-определениях)
  * [3.5 Переменные и конкатенация](#35-переменные-и-конкатенация)
  * [3.6 Магические числа](#36-магические-числа)
  * [3.7 Константы](#37-константы)
* [4. Подробнее про строки](#4-подробнее-про-строки)
  * [4.1 Интерполяция](#41-интерполяция)
  * [4.2 Индексация](#42-индексация)
  * [4.3 Срезы строк](#43-срезы-строк)
  * [4.4 Multi-line строки](#44-multi-line-строки)
* [5. Типы данных](#5-типы-данных)
  * [5.1 Примитивные типы данных](#51-примитивные-типы-данных)
  * [5.2 Строгая типизация](#52-строгая-типизация)
  * [5.3 Преобразование переменных](#53-преобразование-переменных)
  * [5.4 Неизменяемость примитивных типов данных](#54-неизменяемость-примитивных-типов-данных)
* [6. Вызов функций](#6-вызов-функций)
  * [6.1 Встроенные функции и их вызов](#61-встроенные-функции-и-их-вызов)
  * [6.2 Сигнатура функции](#62-сигнатура-функции)
  * [6.3 Аргументы по умолчанию](#63-аргументы-по-умолчанию)
  * [6.4 Вызов функции — выражение](#64-вызов-функции--выражение)
  * [6.5 Функции с переменным числом параметров](#65-функции-с-переменным-числом-параметров)
  * [6.6 Детерминированность](#66-детерминированность)
  * [6.7 Стандартная библиотека](#67-стандартная-библиотека)
* [7. Свойства и методы](#7-свойства-и-методы)
  * [7.1 Объекты](#71-объекты)
  * [7.2 Неизменяемость](#72-неизменяемость)
  * [7.3 Методы как выражения](#73-методы-как-выражения)
  * [7.4 Цепочка вызовов](#74-цепочка-вызовов)

## 1. Арифметика

### 1.1 Операторы и операнды

`Операторы` — это специальные символы или ключевые слова, который выполняет операцию над одним или несколькими операндами. Операторы делятся на три основных типа: унарные, бинарные, тернарные. Также существуют различные категории операторов: арифметические операторы, логические операторы, операторы сравнения, операторы присваивания, битовые операторы, операторы идентичности и операторы членства.

`Операнды` — это переменные или значения, над которыми проводится операция. Они могут быть простыми значениями или сложными выражениями, включающими другие операторы и операнды.

```txt
Арифметические операторы:

+ — сложение
- — вычитание
** — возведение в степень
/ — деление
// — целочисленное деление
% — остаток от деления
```

Более подробно об остальных категориях операторов можно узнать [тут](https://pythonru.com/osnovy/operatory-python).

***

### 1.2 Коммуникативные операции

`Коммуникативные операции` — обычно это сложение. Во всех остальных действиях очень важно следить за порядком.

```txt
7 + 3 = 3 + 7
7 - 3 не = 3 - 7
```

***

### 1.3 Композиция операций

`Композиция операций` — это операции, в которых соединяются друг с другом всё более сложные составные выражения. Приоритет определяется операндами или же если нужна определённая последовательность, то ставятся скобки. Главное закрывать скобки в правильном порядке.

```python
# Порядок действий определяется операторами
print(10 / 4 + 7 - -5 / 4)

# Порядок действий определяется скобками
print(((10 / 4) + 7) - (-5 / 4))
```

***

### 1.4 Числа с плавающей точкой

`Числа с плавающей точкой` — это числовой тип данных, который используется для представления действительных чисел, включая дробную часть. Python позволяет работать с числами практически любой длины, точность чисел с плавающей точкой ограничена примерно 15–16 значащими цифрами. Из-за особенностей хранения чисел в двоичной системе возникают небольшие погрешности при представлении некоторых десятичных значений.

```py
# Пример сложения чисел с плавающей точкой
print(0.1 + 0.2)  # 0.30000000000000004

# Результат будет отличаться от ожидаемого из-за ограниченной точности
print(12.3456 + 0.000001)  # 12.345600999999998
```

Объём памяти, в отличие от чисел, конечен.

## 2. Строки

### 2.1 Кавычки

Какие **кавычки** выбирать, зависит от удобства программиста, а также выбора команды. И тот, и другой вариант будет верным.

```py
# Можно использовать как одинарные кавычки..
print('Dragon\'s mother said "No"')
# так и двойные
print("Dragon's mother said \"No\"")
```

***

### 2.2 Экранированные последовательности

`Экранированные последовательности` — это специальные комбинации символов, которые помогают добавлять в строки символы, которые трудно или невозможно ввести прямо с клавиатуры. Их существует несколько десятков, но часто встречаются только некоторые. К таким относятся:

* перенос \n — на другую строку
* табуляция \t — получается при нажатии на кнопку Tab
* возврат каретки \r — работает только в Windows

Пример использования:

```python
# Можно разделять строки, но строка должна содержать только символ \n
print("Dean")
print("\n")
print("Winchester")
```

***

### 2.3 Конкатенация

`Конкатенация` — это операция объединения двух или более строк в одну строку. В Python конкатенация выполняется с помощью оператора "+" между строковыми объектами.

```py
# Пример конкатенации
print("Fall " + "seven " + "times " + "and " + "stand " + "up " + "eight.")
```

***

### 2.4 Кодировка

Существуют разные типы **кодировок**, такие как **UTF-8** или **ASCII**. Каждый символ закодирован цифрой. Кодировка ASCII поддерживает только латинские символы и некоторые специальные знаки, тогда как UTF-8 позволяет хранить символы множества различных алфавитов, включая кириллицу, китайские иероглифы и даже эмодзи.

```py
# Число 126 соответствует символу "~" в кодировке ASCII
print(chr(126))

# Символ "~" соответствует числу 126 в кодировке ASCII
print(ord("~"))
```

Когда данные сохраняются или передаются в неправильной кодировке, это может привести к проблемам с отображением символов. Чаще всего используют кодировку UTF-8, так как она обеспечивает практически максимальную совместимость.

## 3. Переменные

### 3.1 Применение переменных

`Переменные` — это способ временного хранения значений, чтобы потом обращаться к ним по имени для дальнейшего использования в коде. В отличие от некоторых других языков программирования, в Python переменным не нужно заранее объявлять тип данных — интерпретатор сам определяет тип значения, которое присваивается переменной.

```py
# Вместо использования одного слова несколько раз..
print("Brother!")
print("Brother!")

# можно использовать переменную, которой присвоено это значение
greeting = "Brother!"
print(greeting)
```

***

### 3.2 Изменение переменных

`Изменение переменных` — это процесс обновления значения, которое хранится в памяти программы под определенным именем. Для разных ситуаций существуют разные сценарии изменения переменных.

```py
# Было присвоено одно значение, которое..
greeting = "Brother!"
print(greeting)

# в процессе поменяли
greeting = "Sister!"
print(greeting)
```

***

### 3.3 Назначение имён для переменных

Стоит учитывать, что **назначение имён для переменных** в первую очередь делается для облегчения восприятия кода людьми, поэтому имена переменных должны отражать суть хранимых в них данных. В языке программирования Python существует несколько основных правил:

* имя должно отражать суть хранимых в переменной данных
* используются строчные буквы
* для разделения используется символ подчёркивания (first_person, second_num и т.д.)

Ознакомиться более подробно с правилами назначения имён для переменных можно [тут](https://peps.python.org/pep-0008/#naming-conventions).

Пример правильного назначения имён для переменных:

```py
first_num = 20  # первое число
second_num = -100  # второе число

print(first_num * second_num)  # их произведение
```

***

### 3.4 Выражения в определениях

`Выражения в определениях` — это такие фрагменты кода, которые используются внутри определений различных структур языка, таких как функции, классы, циклы, условия и другие конструкции. Проще говоря, `выражение` — это комбинация операторов, переменных, литералов и вызовов функций, которая возвращает какое-то значение.

```py
euros_count = 100

# Евро в долларах
dollar_count = 100 * 1.25
print(dollar_count)  # => 125.0

# Доллары в юанях
yuans_count = dollar_count * 6.91
print(yuans_count)  # => 863.75

print("Euros: " + str(euros_count) + " " + "Dollars: " + str(dollar_count) + " " + "Yuans: " + str(yuans_count))  # => Euros: 100 Dollars: 125.0 Yuans: 863.75
```

В тех местах, где ожидается выражение, можно поставить любое вычисление. Оно может быть не только математическим, но и строковым — как конкатенация.

Любая переменная может быть частью любого выражения. В момент вычисления вместо имени переменной подставляется ее значение.

***

### 3.5 Переменные и конкатенация

Как и с обычными выражениями, можно использовать **переменные с конкатенацией**. Синтаксически ничего не поменяется.

```py
first_name = "Johnny"
greeting = "Hello"

print(greeting + ", " + first_name + "!")  # => Hello, Johnny!
```

***

### 3.6 Магические числа

`Магические числа` — это числа, происхождение которых невозможно понять с первого взгляда. В конечном итоге приходится глубоко вникать в код. Для предотвращения проблемы, нужно создавать переменные с правильными именами. Названия переменных должны передавать смысл, но должны при этом оставаться достаточно короткими и ёмкими для комфортного чтения.

```py
# В большом кол-ве кода будет тяжело понять происхождение
castles = 6
rooms = 17

# Сохраняется краткость и информативность
number_of_castles = 6
rooms_per_castle = 17
```

Магические числа и непонятные именования переменных не ломают код, но делают его менее читабельным. Правильное именование переменных — половина успеха анализа кода.

***

### 3.7 Константы

`Константы` — это переменные, значения которых не меняются на протяжении всей программы. Самым простым примером являются математические постоянные.

```py
# Число "Пи"
PI = 3.14
print(PI)  # => 3.14
```

Константа создается так же, как переменная. Разница только в том, что константы принято именовать заглавными буквами. Константа, как и переменная, может использоваться в любом выражении.

## 4. Подробнее про строки

### 4.1 Интерполяция

Базовый способ соединения строк — `конкатенация`. Конкатенация работает просто, но выглядит не всегда наглядно. У конкатенации есть альтернатива — `интерполяция`.

```py
first_name = "Brother"
greeting = "Hello"

print(f"Hello, {first_name}!")  # => Hello, Brother!
print(f"{greeting}, {first_name}!")  # => Hello, Brother!
```

Буква f указывает на то, что мы создаем `f-строку` — шаблон, в который с помощью фигурных скобок подставляются значения переменных. В результате получается обычная строка.

Почти во всех языках для объединения строк интерполяция предпочтительнее конкатенации. Строка при этом получается склеенная, и внутри неё хорошо просматриваются пробелы и другие символы. Интерполяция помогает сделать код более понятным и чистым.

***

### 4.2 Индексация

Иногда нужно получить один символ из строки. Например, если знать имя и фамилию пользователя, и в какой-то момент требуется вывести эту информацию в формате A. Ivanov.

`Индекс` — это целое число, которое используется для обращения к элементу последовательности. Индексы начинаются с 0 почти во всех языках программирования. Индекс последнего элемента равен длине строки минус единица. Обращение к индексу за пределами строки приведет к ошибке.

```py
# Длина строки девять символов
first_name = "Alexander"

# Если нам нужен первый символ, то из 1 - 1 = 0
print(first_name[0])  # => A

# Если нам нужен последний символ, то из 9 - 1 = 8
print(first_name[8])  # => r
```

Допустимо использовать отрицательные индексы. В этом случае идет обращение к символам, начиная с конца строки. -1 — индекс последнего символа, -2 — предпоследнего и так далее. В отличие от прямой индексации, обратный отсчет идет от -1. А так же индексом может быть не только число, но и значение переменной.

```py
# Длина строки девять символов
first_name = "Alexander"

# Обратный отсчёт идёт с конца
print(first_name[-1])  # => r

# Индекс записанный в переменную
index = 0

# Индекс равен нулю записанному в переменную index
print(first_name[index])  # => A
```

Стоит знать, что **\n** и другие экранированные последовательности, являются одним целым символом:

```py
# Теперь длина строки десять символов..
first_name = "Alex\nander"

# соответственно индекс последней буквы будет равен девяти
print(first_name[9])  # => r
```

***

### 4.3 Срезы строк

`Срезы для строк` — это механизм, с помощью которого извлекается подстрока по указанным параметрам.

`Подстрока` — это некоторая часть строки, которую нужно найти и извлечь.

Представим, что у нас есть дата в таком формате: 07-07-2077. Нужно извлечь из нее подстроку, в которую входит только год.

```py
date = "07-07-2077"

# Извлечение подстроки, в которую входит только год
year = date[6:10]
print(year)  # => 2077
```

`Срезы` — механизм с большим количеством вариаций. Например, если не указать вторую границу, то извлечение произойдет до конца строки. То же самое с первой границей — началом строки:

```py
value = "Python"
value[3:]  # => "hon"
value[:3]  # => "Pyt"
```

Можно указать даже отрицательные индексы. В таком случае отсчет идет с обратной стороны:

```py
value = "Python"
# Правая граница отрицательная, поэтому считаем -1 от конца строки
value[3:-1]  # "ho"
# Левая граница отрицательная, поэтому считаем -5 от конца строки
value[-5:3]  # "yt"
```

У срезов есть третий необязательный параметр — **шаг извлечения**. По умолчанию он равен единице, но мы можем его изменить:

```py
value = "Python"
value[1:5:2]  # "yh"
# Срез 1:5 это "ytho"
# Шаг 2 это каждый второй, то есть "y" и "h"
```

Всё это можно комбинировать с открытыми границами, то есть без указания начала или конца:

```py
value = "Python"
value[:5:2]  # "Pto"
```

Шаг может быть отрицательным, в таком случае он берется с конца. Из этого вытекает самый популярный способ использования шага — **переворот строки**:

```py
value = "Python"
value[::-1]  # "nohtyP"
```

Если используется отрицательный шаг, и элементы среза извлекаются в обратном порядке — тогда и границы среза тоже нужно указывать в обратном порядке. Первой указывается правая граница среза, второй — левая:

```py
value = "Python"
# Символ с индексом 1 не будет включен в подстроку
value[4:1:-1]  # "oht"
```

Срезы можно указывать не только через числа, но и с использованием переменных:

```py
value = "Python"
start = 1
end = 5
value[start:end]  # "ytho"
```

Всё в одном месте:

```py
value = "Python"
value[::]  # "Python" — вся строка
value[:]  # "Python" — вся строка
value[::2]  # "Pto" — четные по порядку символы
value[1::2]  # "yhn" — нечетные по порядку символы
value[::-1]  # "nohtyP" — вся строка в обратном порядке
value[5:]  # "n" — строка, начиная с шестого символа
value[:5]  # "Pytho" — строка до шестого символа
value[-2:1:-1]  # "oht" — все символы с предпоследнего до третьего включительно, в обратном порядке
```

Во всех случаях выборки от большего индекса к меньшему нужно указывать шаг.

***

### 4.4 Multi-line строки

В Python есть еще один способ создания строк, который называется **multi-line строки**. Чтобы описать такую «многострочную строку», нужно заключить ее в тройные кавычки — """ или '''. Внутри multi-line строки можно переносить текст и не использовать перевод строки \n:

```py
text = """Пример текста,
состоящего из
нескольких строк.
"""
```

```txt
Пример текста,
состоящего из
нескольких строк.

```

В конце текста появилась пустая строка. Она появилась в тексте потому, что мы поставили закрывающие кавычки """ на новой строке. Если не переносить закрывающие кавычки на новую строку, то пустая строка в тексте не появится:

```py
text = """Пример текста,
состоящего из
нескольких строк."""
```

```txt
Пример текста,
состоящего из
нескольких строк.
```

Из-за тройных кавычек multi-line строки позволяют не экранировать кавычки внутри строки:

```py
text = """Здесь не нужно экранировать 'одинарные' и "двойные" кавычки."""
```

```txt
Здесь не нужно экранировать 'одинарные' и "двойные" кавычки.
```

А ещё multi-line строки могут становиться f-строками для интерполяции:

```py
a = "A"
b = "B"

text = f"""{a} и {b}
сидели на трубе
"""
```

```txt
А и B
сидели на трубе

```

Таким образом, multi-line строки помогают писать код более читабельно и структурировано, особенно когда нужно работать с большими объемами текста.

## 5. Типы данных

### 5.1 Примитивные типы данных

Есть `строки` — наборы символов в кавычках вроде "Hello, World!". Есть `целые числа` — например, 7, -198, 0. Есть `рациональные числа` — например, 7.77, -3.52, 202.02. Есть `логические` — принимают два состояния: True(правда) или False(ложь). Есть `None` — указывает на то, что значения пока неизвестно или не определено.

```py
# Строка
print("Hello, World!")  # => Hello, World!

# Целое число
print(7)  # => 7

# Рациональное число
print(7.77)  # => 7.77

# Логический тип
has_error = True

# Тип None
result = None
```

Приведенные выше примеры являются **примитивными типами данных**. `Примитивные типы данных` — простые типы, встроенные в сам язык программирования.

***

### 5.2 Строгая типизация

Python — один из языков, который строго относится к типам данных. Поэтому на любую несовместимость типов он ответит ошибкой. Не получится сложить число и строку, потому что это разных типы данных. Нужно сначала привести их к одному типу данных. Такое отношение к совместимости типов данных называется `строгой типизацией` или `сильной типизацией`.

```py
print(7 + "7")  # => TypeError: unsupported operand type(s)..
```

Не все языки программирования являются строго типизированными. Например PHP и JavaScript — это языки со слабой типизацией. То есть в них присутствует автоматическое преобразование типов тогда, когда это кажется логичным. На практике оно создаёт множество ошибок и проблем, которые трудно найти в коде. Код может работать, а иногда и вовсе не работать — в зависимости от того, "повезло" ли с автоматическим преобразованием.

```js
// Пример слабой типизации в JavaScript
7 + "7" = 77; // число 7 + строка 7 = строка 77
```

***

### 5.3 Преобразование переменных

Предыдущая тема показала нам важность приведения типов данных при работе с переменными разных типов. Это позволяет избежать ошибок и обеспечивает корректность выполнения операций. Приведение типов в Python выполняется следующим образом:

```py
# str станет int
value = int("777")
print(value)  # => 777 (int)

# int станет str
value2 = str(777)
print(value2)  # => "777" (str)

# bool станет str
value3 = str(True)
print(value3)  # => "True" (str)

# int станет float
value4 = float(5)
print(value4)  # => 5.0 (float)
```

Python также способен автоматически приводить типы данных в некоторых случаях. Например, когда вы выполняете арифметические операции с целым числом и числом с плавающей точкой, результат будет приведен к типу float:

```py
# Пример автоматического приведения типа
value = 7 + 7.7
print(value)  # => 14.7 (float)
```

***

### 5.4 Неизменяемость примитивных типов данных

В Python существует понятие неизменяемых (immutable) и изменяемых (mutable) типов данных. Примитивные типы данных, такие как целые числа (int), числа с плавающей точкой (float), строки (str) и булевы значения (bool), относятся к категории неизменяемых.

`Неизменяемый тип данных` — это такой тип, который после своего создания нельзя изменить. Любая операция над неизменяемым объектом создает новый объект, а исходный остается прежним.


```py
# Создание нового объекта для правильного замены
first_name = "Jack"
first_name = "Back"

print(first_name)  # => Back

# Попытка изменения строки, которая ведёт к ошибке
first_name = "Jack"
first_name[0] = "B"

print(first_name)  # => TypeError: 'str' object does not support item assignment
```

## 6. Вызов функций

### 6.1 Встроенные функции и их вызов

Одна встроенная функция уже фигурировала ранее — **print()**:

```py
result = 77
print(result)  # => 77
```

Функция **len()** считает количество символов в строке:

```py
result = len("Hello!")
print(result)  # => 6
```

Или же функция **pow()**, которая возводит число в нужную степень. Она принимает на вход два параметра: берет первый параметр и возводит его в степень, переданную вторым параметром:

```py
result = pow(2, 3)  # 2 * 2 * 2
print(result)  # => 8
```

И это далеко не весь перечень встроенных функций.

***

### 6.2 Сигнатура функции

`Сигнатура функции` — это своего рода "инструкция", которая описывает, какие аргументы функция принимает и в каком порядке.

Рассмотрим на примере уже изученной ранее функции **pow()**, которая принимает два аргумента: **какое число возводить** и **в какую степень**. Если вызвать эту функцию без параметров, то это приведёт к следующей ошибке: **"TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'str'"**. Результат вызова функции — тоже всегда число.

Другая функция может иметь другое число параметров и другие типы параметров. Узнать подробнее о конкретной функции можно в документации. О встроенных функциях можно прочитать в [официальной документации Python](https://docs.python.org/3/library/functions.html) или в [неофициальной документации на русском языке](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/). Документация даёт понять, сколько аргументов у функции и какого она типа, а также она описывает, что возвращает функция и какого типа будет возвращаемое значение.

Обычно документация выглядит вот так:

```txt
pow(x, y[, z])

Возвращает x в степени y; если z присутствует, возвращает x в степени y, по модулю z
```

***

### 6.3 Аргументы по умолчанию

`Аргументы` — это данные, которые передаются в функцию, чтобы она могла выполнить свою работу.

Рассмотрим для примера функцию round(), которая округляет переданное ей число:

```py
# Функция с указанием необязательного параметра
result = round(10.25, 0)  # 10.0
```

Мы передали в неё два аргументы:

* число, которое нужно округлить
* точность округления

0 означает, что округление будет до целого числа. Чаще всего требуется округлять именно до целого числа, поэтому второй параметр в функции round() является **необязательным**.

```py
# Функция без указания необязательного параметра
result = round(10.25)  # 10.0
```

Если же нужна другая точность, то нужно будет задать параметр:

```py
# Округление до одного знака после запятой
result = round(10.25, 1)  # 10.2
```

Если функция принимает в себя необязательные аргументы, их количество будет зависеть от самой функции, но они всегда будут идти рядом и в конце списка аргументов.

***

### 6.4 Вызов функции — выражение

`Выражение` — это комбинация переменных, констант, операторов и функций, результатом которой является значение определенного типа данных.

Особенность выражений в том, что они возвращают результат, который можно использовать дальше:

```py
# Тут выражением является 3 + 7 * 5
first_num = 3 + 7 * 5

# Тут выражением является 5 + 7 - 10
second_num = 5 + 7 - 10

# А вот тут выражением уже является first_num * second_num
result = first_num * second_num
```

Не всё в программировании является выражением. Определение переменной — это инструкция, а значит, переменная без конкретного присвоенного ей значения не может быть частью выражения.

```py
# Переменной не присвоено значение, код не сработает
10 + sum = 1 + 5
```

Функции возвращают результат — значит, они выражения. Исходя из этого понятно, что можно использовать вызов функций прямо в математических операциях.

```py
# Индексы начинаются с нуля, поэтому его тоже считаем
name = "python"

# Используется интерполяция
print(f"Последний символ: {name[len(name) - 1]}")
```

Выражения можно комбинировать, получая всё более сложное поведение в разных местах и любым образом.

***

### 6.5 Функции с переменным числом параметров

У некоторых функций есть особенность — они принимают переменное число параметров. Например функция **max()**. Если обратиться к [документации](https://docs.python.org/3/library/functions.html#max) этой функции, то можно сразу заметить такую конструкцию:

```py
# Конструкция функции max()
max(arg1, arg2, *args[, key])
```

Это значит, что **max()** принимает на вход два параметра и больше:

```py
# Пример работы функции max()
max(1, -4, 12, 9, 12)  # 12
```

Существует функция **min()**, которая работает аналогично функции **max()**. Отличие заключается в том, что она возвращает минимальное число.

```py
# Пример работы функции min()
min(7, 10, 32, -3, 0, -3)  # -3
```

Если функция найдет несколько параметров с максимальным или минимальным значением, значит, она вернет самый первый из них.

***

### 6.6 Детерминированность

`Детерминированность` означает, что программа или её отдельные части ведут себя предсказуемым образом — одинаковые входные данные приводят к одинаковым результатам каждый раз, независимо от внешних факторов.

```py
# Длина строки 6 символов
len("Python")

# Такой же результат получаем и во второй раз
len("Python")
```

`Недетерминированность` возникает тогда, когда поведение программы непредсказуемо даже при повторении одного и того же сценария.

```py
# Импорт модуля
from random import random

# Функция, которая возвращает случайное число
random()  # первый результат
random()  # второй результат, отличный от первого
```

Детерминированные функции удобны в работе — их легко оптимизировать и тестировать. Если возможно, то лучше сделать функцию детерминированной.


***

### 6.7 Стандартная библиотека

`Стандартная библиотека` — это набор встроенных модулей и пакетов, которые поставляются вместе с интерпретатором Python и предоставляют разработчикам широкий спектр функций и инструментов для решения различных задач программирования без необходимости устанавливать дополнительные библиотеки извне.

[Стандартная библиотека Python](https://docs.python.org/3/library/index.html) представляет собой мощный инструментарий, позволяющий решать большинство повседневных задач разработки без привлечения сторонних библиотек.

Важно помнить, что для любой задачи существует множество подходов к решению, каждый из которых обладает своими преимуществами и недостатками. Опытные разработчики выбирают тот метод, который обеспечивает наилучшую эффективность и оптимизацию. По мере накопления опыта разработчики расширяют свой кругозор и совершенствуют профессиональные навыки. Таким образом, обладая большим опытом, гораздо легче находить оптимальные решения различных задач.

Советы, которые могут повысить уровень профессионализма:

* **Всегда отслеживайте, с каким типом данных вы работаете.** Так вы найдете необходимую функцию в соответствующем разделе документации.

* **Чаще читайте чужой код на GitHub.** Особенное внимание обращайте на код библиотек, которые используете.

* **Изучайте документацию.** Стандартная библиотека обширна, и знание её возможностей существенно ускорит разработку и повысит качество вашего кода.

* **Создавайте читаемый и поддерживаемый код.** Соблюдение стандартов [PEP 8](https://peps.python.org/pep-0008/) сделает ваш код понятным другим разработчикам и облегчит дальнейшую поддержку проекта.

## 7. Свойства и методы

### 7.1 Объекты

`Объектно-ориентированное программирование (ООП)` — это парадигма программирования, основанная на концепции объектов, которые содержат данные в виде полей (атрибутов) и методы, позволяющие манипулировать этими данными. ООП позволяет структурировать программы таким образом, чтобы упростить повторное использование и поддержку программного кода.

`Объект` — это экземпляр конкретного класса. Объект имеет состояние (хранит значения переменных-членов) и поведение (методы). Один класс может иметь много экземпляров, каждый из которых хранит свое собственное уникальное состояние.

**Эти темы настолько обширны и важны, что требуют отдельного глубокого изучения, поэтому мы рассмотрим их позже, уделив каждому моменту отдельное внимание.**

```py
name = "Python"
# Использование метода upper()
upper_name = name.upper()
print(upper_name)  # => "PYTHON"
```

Строки в Python — это объекты. В примере выше мы вызываем метод, то есть функцию, которая связана со строкой. Вызов происходит через точку, которая идет сразу за именем переменной. В остальном методы работают как обычные функции.

```py
# Вызов напрямую
"Python".upper()  # "PYTHON"
```

В строки встроено много методов, которые постоянно нужны разработчику. Посмотреть их список можно в [документации](https://docs.python.org/3/library/stdtypes.html#string-methods).

Тоже самое касается чисел и остальных типов данных. Можно сказать, что в Python почти всё — объекты:

```py
x = -7
# Возвращает модуль числа
# Имя выглядит странно, но это действительно метод
x.__abs__()
```

В примере выше есть имя метода с двумя подчеркиваниями в начале и в конце. В Python так называют методы, которые не предназначены для прямого вызова. Для них создали функции, которые внутри себя уже сами вызывают методы:

```py
x = -7
abs(x)  # вызывает x.__abs__()
pow(x, 3)  # вызывает x.__pow__(3)
```

Так же работает и функция **len()**:

```py
len("Hexlet")  # Вызывает "Hexlet".__len__()
```

Кроме методов у объектов есть атрибуты, но у встроенных в Python объектов их мало. Например, атрибут __doc__, который возвращает документацию функции. Поэтому функции тоже считаются объектами:

```py
len.__doc__ # "Return the number of items in a container."
```

Атрибуты работают и выглядят как переменные, только указываются через точку после объекта.

***

### 7.2 Неизменяемость

`Неизменяемость` — это свойство объектов в Python, означающее, что объект нельзя изменить после его создания. Любые операции над такими объектами приводят либо к созданию нового объекта, либо возвращают новый экземпляр, сохраняя исходный объект неизменным.

```py
name = "Benny"
print(name.upper())  # => BENNY
# Исходные данные останутся неизменными
print(name)  # => Benny
```

Вместо того чтобы изменять значения, можно **заменить** значение.

```py
name = "Benny"
name = name.upper()
print(name)  # => BENNY
```

***

### 7.3 Методы как выражения

Методы — такие же выражения, как переменные или вызовы функции, значит, их можно по-разному комбинировать.

Например, использовать в операциях:

```py
name = "Triss"
"hi, " + name.upper() + "!"  # hi, TRISS!
```

Или использовать в параметрах функций:

```py
num1 = 7
num2 = 34
# bit_length() — вычисляет количество бит, необходимых для представления числа в двоичном виде
print(num1.bit_length() + num2.bit_length())  # => 9
```

***

### 7.4 Цепочка вызовов

У нас есть следующий код:

```py
name = "Triss"
print(name.upper().lower())  # => "triss"
```

Чтобы понять, как работает этот код, нужно разбить цепочку на отдельные операции:

1. Изначально переменная name хранит строку "Triss". Мы вызываем метод .upper(), который переводит все буквы строки в верхний регистр (заглавные). Первая операция даст нам новую строку: "TRISS".

2. После первого шага мы получили строку "TRISS". Теперь на неё накладывается второй метод — .lower(), который переводит все буквы строки обратно в нижний регистр (строчные). Таким образом, вторая операция вернёт нам строку: "triss".

3. Программа выведет результат последней операции, то есть строку "triss".

```py
name = "Triss"
upper_name = name.upper()  # "TRISS"
print(upper_name.lower())  # "triss"
```

Первый и второй примеры эквивалентны. Мы можем выполнять операции последовательно с промежуточным созданием переменных, а можем строить непрерывную цепочку из атрибутов и методов. В цепочках вычисления всегда идут слева направо.
